/*! \file main.c
*
* DEPENDECIES: Kvaser CAN library: lcanlib lpthread
* 
*
* CMAKE: change to build folder and run the following CMAKE command to build a Eclipse project
*       ~\$ cd /build  
*       ~\$ cmake -G"Eclipse CDT4 - Unix Makefiles" -D CMAKE_BUILD_TYPE=Debug ../source 
*
*            Import the created project file into Eclipse
*
*            Import project using Menu File->Import
*            Select General->Existing projects into workspace:
*            Browse where your build tree is and select the root build tree directory. Keep "Copy projects into workspace" unchecked.
*            You get a fully functional eclipse project
*
*
*            I just spent some time struggling with this macro so I wanted to post an
* example. Maybe this can be used to expand on the documentation.
*
* First you need to collect all the headers on which you want to run moc:
*
* set (FOO_MOC_HEADERS foo_header.h)
*
* Next, you pass these headers to the qt4_wrap_cpp macro. You *also* pass
* a variable which will be populated with paths to the .cpp files
* generated by moc:
*
* qt4_wrap_cpp (FOO_MOC_OUTFILES ${FOO_MOC_HEADERS})
*
* Finally, you include the generated .cpp files generated by moc with your
* application/library:
*
* add_library (foo SHARED ${FOO_SOURCE_FILES} ${FOO_MOC_OUTFILES})
*
*
* The process is pretty simple, but deciphering that process was confusing
* to me so I hope this simple example is helpful.
*
*/

#include <canlib.h>
#include <stdio.h>
#include <iostream>
#include <signal.h>
#include <QSettings>
#include <QObject>
#include <QTime>
#include <QDir>
#include <QTextStream>
#include <math.h>


#define SAMPLE_TIME_MS 2

//#include "../../motorDriverBoardConfiguration/source/KvaserCanInterface.h"
#include "UserInterface.h"
#include "FlexRayUSBInterface.h"
#include  "../../../myode/src/eu.myode.Myorobot/robot/CommunicationData.h"

#define CONTROL_MODE Force //Force ;//Raw // Torque //Velocity//Position// Raw//Raw;  //Raw;
#define MUSCLE1 1
#define MUSCLE2 3
#define GANGLION 0

 #include <QCoreApplication>
using namespace std;

//can appliation




void delay( int millisecondsToWait )
{
    QTime dieTime = QTime::currentTime().addMSecs( millisecondsToWait );
    while( QTime::currentTime() < dieTime )
    {
        QCoreApplication::processEvents( QEventLoop::AllEvents, 100 );
    }
}



UserInterface::UserInterface()
{
	cout<<"User Interface started:"<<endl;
}

void UserInterface::initGlobalSafeCommandFrame()
{
	//global parameter structures
	//comsCommandFrame allGlobalCommandFrames[NUMBER_OF_GANGLIONS];
	//control_Parameters_t oneGlobalSetOfControlParameters;
	// Command all motors connected to all Ganglions into disabled mode, also set to raw mode with 0% pwm activation

	cout<<endl<<endl<<endl<<"CREATING SAFE COMMAND FRAME!"<<endl;
	for(int j=0;j<NUMBER_OF_GANGLIONS;j++)
	{
			for(int i=0;i<4;i++)
			{
				allGlobalCommandFrames[j].ControlMode[ i ]   = Raw;
				allGlobalCommandFrames[j].OperationMode[ i ] = Disable; //Initialise; //Run
				allGlobalCommandFrames[j].sp[i] 		  = 0;


			}
	}

	//set the dynamic config parameters to 0
	oneGlobalSetOfControlParameters.tag = 0;			// sint32
	oneGlobalSetOfControlParameters.outputPosMax = 0;	// sint32			// set arbitary max position
	oneGlobalSetOfControlParameters.outputNegMax = 0;		// sint32
	oneGlobalSetOfControlParameters.spPosMax = 0;		// float32
	oneGlobalSetOfControlParameters.spNegMax = 0;		// float32
	oneGlobalSetOfControlParameters.timePeriod = 10000;		// float32		//in us// set time period to avoid error case
	oneGlobalSetOfControlParameters.radPerEncoderCount = 0;	// float32
	oneGlobalSetOfControlParameters.polyPar[0] = 0;		// float32
	oneGlobalSetOfControlParameters.polyPar[1] = .9482; 	//proportional linear mapping from displacement to force (Force = polyPar[1]  * displacementSensorOutput)
	oneGlobalSetOfControlParameters.polyPar[2] = 0;
	oneGlobalSetOfControlParameters.polyPar[3] = 0;
	oneGlobalSetOfControlParameters.torqueConstant = 1;	// float32

	oneGlobalSetOfControlParameters.params.pidParameters.integral = 0;	// float32
	oneGlobalSetOfControlParameters.params.pidParameters.pgain = 0;		// float32
	oneGlobalSetOfControlParameters.params.pidParameters.igain = 0;		// float32
	oneGlobalSetOfControlParameters.params.pidParameters.dgain = 0;		// float32
	oneGlobalSetOfControlParameters.params.pidParameters.forwardGain = 0;	// float32
	oneGlobalSetOfControlParameters.params.pidParameters.deadBand = 0;	// float32
	oneGlobalSetOfControlParameters.params.pidParameters.lastError = 0;	// float32
	oneGlobalSetOfControlParameters.params.pidParameters.IntegralPosMax = 0;	// float32
	oneGlobalSetOfControlParameters.params.pidParameters.IntegralNegMax = 0;	// float32

}


void UserInterface::GanglionDataDisplay(ganglionData_t * newData)
{
	static int exchangeCounter=0;
	static int firstTime=1;
	ganglionData_t ganglionFeedbackData[NUMBER_OF_GANGLIONS];
	memcpy(ganglionFeedbackData,newData, sizeof(ganglionData_t)*NUMBER_OF_GANGLIONS);
	//cout<<"USB DATA ARRIVED:"<<endl;


		/*
		 * add stuff to initialise at start-up below
		 */

		//only called once!
		if (firstTime)
		{
			accutime=0;
			elapsedTime.start();
			firstTime=0;

		}

		//just a few timing values in case we would like to record its
		//accutime=0;
		//cout<<".";
		nanoSec = elapsedTime.nsecsElapsed();
		elapsedTime.restart();

		//accumulate the delta-times to micro-second precision running time
		accutime+=(unsigned long) (nanoSec+500)/1000;
		//cout<<"ns: "<<accutime<<endl;




		//(*mfileOutput) <<exchangeCounter++<<",  "<<nanoSec/1000<<", "<<accutime <<" ,"<<ganglionFeedbackData[GANGLION].muscleState[3].jointPos<<endl;
		//cout<<"Data after emit:"<<endl;
		//cout<<ganglionFeedbackData[GANGLION].muscleState[3].actuatorPos<<",  "<<ganglionFeedbackData[GANGLION].muscleState[3].actuatorCurrent <<",  "<<ganglionFeedbackData[GANGLION].muscleState[0].jointPos <<endl;
		//cout<<"OpMode: "<<ganglionFeedbackData[GANGLION].muscleState[0].jointPos<<",   ConMode: "<<ganglionFeedbackData[GANGLION].muscleState[1].jointPos<<endl;
		//cout.flush();
		(*mfileOutput) <<exchangeCounter++<<",  "<<nanoSec/1000<<", "<<ganglionFeedbackData[GANGLION].muscleState[MUSCLE1].actuatorPos<<",  "<<ganglionFeedbackData[GANGLION].muscleState[MUSCLE1].actuatorVel <<",  "<<ganglionFeedbackData[GANGLION].muscleState[MUSCLE1].actuatorCurrent<<", "<<ganglionFeedbackData[GANGLION].muscleState[MUSCLE1].tendonDisplacement<<", "<<ganglionFeedbackData[GANGLION].muscleState[MUSCLE1].jointPos<<endl;
}



void UserInterface::setLogFilePointer(QTextStream * fileOutput)
{
	mfileOutput=fileOutput;
}

void UserInterface::run()
{
	int input=0;
	static int runFullSpeed=0;
	int motorID=3;

	while (input!=9)
	{
	cout<<"User Interface: 0 to stop motor, 1 to start motor, 2 disable logging, 3 enable logging,  5 to set reference, "<<endl;
	cout<<" 6, set controller1 time, 7, set controller 2 time  9 to end application (return)"<<endl;
	cin>>input;
	cout<<"Input was "<<input<<endl<<endl;
	if (input==0)
	{
		cout<<"disable all motors"<<endl;

		allGlobalCommandFrames[GANGLION].OperationMode[ 0 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 1 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 2 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 3 ]=Disable; //initialise motor, so parameters are copied
		//allGlobalCommandFrames[GANGLION].ControlMode[ 0 ]=Raw; //CONTROL_MODE;
		//allGlobalCommandFrames[GANGLION].ControlMode[ 1 ]=Raw; //CONTROL_MODE;
		//allGlobalCommandFrames[GANGLION].ControlMode[ 2 ]=Raw; //CONTROL_MODE;
		//allGlobalCommandFrames[GANGLION].ControlMode[ 3 ]=Raw; //CONTROL_MODE;
		//allGlobalCommandFrames[GANGLION].ControlMode[ MUSCLE1 ]=CONTROL_MODE;
		allGlobalCommandFrames[GANGLION].sp[3]=0;
		allGlobalCommandFrames[GANGLION].sp[2]=0;
		allGlobalCommandFrames[GANGLION].sp[1]=0;
		allGlobalCommandFrames[GANGLION].sp[0]=0;

		emit setCommandAndParameterFrames(allGlobalCommandFrames, &oneGlobalSetOfControlParameters);

		//emit stopMotors();
	}
	else if (input==1)
	{
		cout<<"enable motor drive signal"<<endl;
		emit startMotors();
	}

	else if (input==2)
	{
		cout<<"disable logging"<<endl;
		emit setLoggingEnable(false);
	}

	else if (input==3)
	{
		cout<<"enable logging"<<endl;
		emit setLoggingEnable(true);
	}

	else if (input==5)
	{
		float reference1, reference2;
		cout<<"       Set Reference value 1(float) (return):"; cin>>reference1;
		cout<<"       Set Reference value 2(float) (return):"; cin>>reference2;
		cout<<endl<<"		!!! reference parameters :"<<reference1<<", "<<reference2<<endl;
		//emit setReference(reference);
		int index;



		 //simple test of correct configuration of modes on ganglion
		for (int k=0; k<4; k++)
		{
			allGlobalCommandFrames[GANGLION].OperationMode[ k ]=Disable;

		}
		allGlobalCommandFrames[GANGLION].OperationMode[ MUSCLE1 ]=Run; //only enable one muscle
		allGlobalCommandFrames[GANGLION].OperationMode[ MUSCLE2 ]=Run; //only enable one muscle

		/*
		if (index>3)
			index=3;
		if (index<0)
			index=0;
		*/

		allGlobalCommandFrames[GANGLION].ControlMode[ 0 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 1 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 2 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 3 ]=Raw;


		allGlobalCommandFrames[GANGLION].ControlMode[ MUSCLE1 ]=CONTROL_MODE;
		allGlobalCommandFrames[GANGLION].ControlMode[ MUSCLE2 ]=CONTROL_MODE;
		allGlobalCommandFrames[GANGLION].sp[0]=0;
		allGlobalCommandFrames[GANGLION].sp[1]=0;
		allGlobalCommandFrames[GANGLION].sp[2]=0;
		allGlobalCommandFrames[GANGLION].sp[3]=0;
		allGlobalCommandFrames[GANGLION].sp[MUSCLE1]=reference1;// only drive the chosen muscle
		allGlobalCommandFrames[GANGLION].sp[MUSCLE2]=reference2;// only drive the chosen muscle

		//allGlobalCommandFrames[5].sp[0]=-reference;
		//allGlobalCommandFrames[5].OperationMode[0]=Run;
		emit setCommandAndParameterFrames(allGlobalCommandFrames, &oneGlobalSetOfControlParameters);
		//emit startMotors();
	}

	else if (input==6)
	{
		float cycleTime1;
		cout<<"CONFIGURE FIRST MOTOR"<<endl;
		cout<<"       Set cycle time value (float) (return):"; cin>>cycleTime1;
		cout<<endl<<"setting controller cycle time in us :"<<cycleTime1<<endl;
		//emit setReference(reference);

		oneGlobalSetOfControlParameters.timePeriod=cycleTime1;
		oneGlobalSetOfControlParameters.outputPosMax=4000;
		oneGlobalSetOfControlParameters.outputNegMax=-4000;

		if (CONTROL_MODE==Torque)
		{
			oneGlobalSetOfControlParameters.outputNegMax=0; //in torque control we only allow positive drive
		}

		oneGlobalSetOfControlParameters.radPerEncoderCount=2*M_PI/4000.0;
		oneGlobalSetOfControlParameters.params.pidParameters.IntegralNegMax=-4000;
		oneGlobalSetOfControlParameters.params.pidParameters.IntegralPosMax=4000;
		oneGlobalSetOfControlParameters.params.pidParameters.deadBand=0;
		oneGlobalSetOfControlParameters.params.pidParameters.forwardGain=0;
		oneGlobalSetOfControlParameters.params.pidParameters.pgain=10;
		oneGlobalSetOfControlParameters.params.pidParameters.igain=0;
		oneGlobalSetOfControlParameters.params.pidParameters.dgain=0;
		oneGlobalSetOfControlParameters.params.pidParameters.integral=0; //initialise the integrator
		oneGlobalSetOfControlParameters.params.pidParameters.lastError=0; //initialise last error

		//this specifies for what controller these parameters are choose from
		/*
		 * Raw=0,
		* Torque,
		* Velocity,
		* Position,
		* Force,
		* JointPosition, //to be removed
		* JointVelocity, // to be removed
		 * */
		oneGlobalSetOfControlParameters.tag=CONTROL_MODE;


		allGlobalCommandFrames[GANGLION].OperationMode[ 0 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 1 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 2 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 3 ]=Disable; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ MUSCLE1 ]=Initialise;
		allGlobalCommandFrames[GANGLION].ControlMode[ 0 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 1 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 2 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 3 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ MUSCLE1 ]=CONTROL_MODE;
		allGlobalCommandFrames[GANGLION].sp[3]=0;
		allGlobalCommandFrames[GANGLION].sp[2]=0;
		allGlobalCommandFrames[GANGLION].sp[1]=0;
		allGlobalCommandFrames[GANGLION].sp[0]=0;

		emit setCommandAndParameterFrames(allGlobalCommandFrames, &oneGlobalSetOfControlParameters);
		//emit startMotors();
	}

	//configure motor 2
	else if (input==7)
	{
		float cycleTime2;

		cout<<"CONFIGURE SECOND MOTOR"<<endl;
		cout<<"       Set cycle time 2 value (float) (return):"; cin>>cycleTime2;
		cout<<endl<<"!!!!!!setting controller cycle time in us :"<<cycleTime2<<endl;
		//emit setReference(reference);

		oneGlobalSetOfControlParameters.timePeriod=cycleTime2;
		oneGlobalSetOfControlParameters.outputPosMax=4000;
		oneGlobalSetOfControlParameters.outputNegMax=-4000;

		if (CONTROL_MODE==Torque)
		{
			oneGlobalSetOfControlParameters.outputNegMax=0; //in torque control we only allow positive drive
		}

		oneGlobalSetOfControlParameters.radPerEncoderCount=2*M_PI/4000.0;
		oneGlobalSetOfControlParameters.params.pidParameters.IntegralNegMax=-1000;
		oneGlobalSetOfControlParameters.params.pidParameters.IntegralPosMax=1000;
		oneGlobalSetOfControlParameters.params.pidParameters.deadBand=0;
		oneGlobalSetOfControlParameters.params.pidParameters.forwardGain=0;
		oneGlobalSetOfControlParameters.params.pidParameters.pgain=10;
		oneGlobalSetOfControlParameters.params.pidParameters.igain=0;
		oneGlobalSetOfControlParameters.params.pidParameters.dgain=0;
		oneGlobalSetOfControlParameters.params.pidParameters.integral=0; //initialise the integrator
		oneGlobalSetOfControlParameters.params.pidParameters.lastError=0; //initialise last error

		//this specifies for what controller these parameters are choose from
		/*
		 * Raw=0,
		* Torque,
		* Velocity,
		* Position,
		* Force,
		* JointPosition, //to be removed
		* JointVelocity, // to be removed
		 * */
		oneGlobalSetOfControlParameters.tag=CONTROL_MODE;


		allGlobalCommandFrames[GANGLION].OperationMode[ 0 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 1 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 2 ]=Disable; //Initialise; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ 3 ]=Disable; //initialise motor, so parameters are copied
		allGlobalCommandFrames[GANGLION].OperationMode[ MUSCLE2 ]=Initialise;
		allGlobalCommandFrames[GANGLION].ControlMode[ 0 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 1 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 2 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ 3 ]=Raw;
		allGlobalCommandFrames[GANGLION].ControlMode[ MUSCLE2 ]=CONTROL_MODE;
		allGlobalCommandFrames[GANGLION].sp[3]=0;
		allGlobalCommandFrames[GANGLION].sp[2]=0;
		allGlobalCommandFrames[GANGLION].sp[1]=0;
		allGlobalCommandFrames[GANGLION].sp[0]=0;

		emit setCommandAndParameterFrames(allGlobalCommandFrames, &oneGlobalSetOfControlParameters);
		//emit startMotors();
	}
	else if (input==9)
	{
		cout<<"Toggle motor control data every 1ms!"<<endl;
		cout<<"Control C to stop application!"<<endl;
	//	emit stopMotors();
	//
	//	emit detachFromApp();
		static int oldSetPoint=0;
		static int toggle=1;
		oldSetPoint= allGlobalCommandFrames[GANGLION].sp[0];


	}




	}

	cout<<"Ending application, please restart."<<endl;


};


//global command frames

int main (int argc, char *argv[])

{

  canHandle handle;
  canStatus status;
  int ret = -1;
  long id;
  unsigned char msg[8];
  unsigned int dlc;
  unsigned int flag;
  unsigned long time;
  int channelCount;
  int channel = 0;
  int bitrate = BAUD_1M;
  int j;
  unsigned int canData[4];

  //some elements to measure time
	 QElapsedTimer elapsedTime;
	 QString logFileName;
	 QFile outputFile;

  QCoreApplication a(argc, argv);



  //prepare log file
 		 QDir configDirectory("");
 		 QString filePath = configDirectory.absolutePath();


 		 filePath.append("UsbFlexRayTiming.txt");
 		 cout<<"log file path: "<<filePath.toStdString()<<endl;
 		 outputFile.setFileName(filePath);

 		 if (outputFile.open(QIODevice::WriteOnly))
 		 {


 			 cout<<"log file open!"<<endl;
 			 //outputFile.close();


 		 }

 		 QTextStream fileOutput(&outputFile);
 	//	fileOutput<<"USB-FlexRay Communication Timing Tests:"<<endl;





  //create instance of FlexRayUSBInterface
  FlexRayUSBInterface* flexUSB= new FlexRayUSBInterface(SAMPLE_TIME_MS); //instance of 200ms update rate flexRay USB interface
  //create new thread for FlexRay USB Interface
  QThread *flexRayThread = new QThread;
  //move drive to the new thread and start it
  flexUSB->moveToThread(flexRayThread);
  flexRayThread->start();


  //user interface for test

  QThread *UserInterfaceThread = new QThread;
  UserInterface *myUserInterface = new UserInterface;
  //obj is a pointer to a QObject that will trigger the work to start. It could just be this
//  connect(obj, SIGNAL(startWork()), worker, SLOT(doWork()));

  //create a global command and parameter frame for test and initialise it.
  myUserInterface->initGlobalSafeCommandFrame();
  myUserInterface->setLogFilePointer(&fileOutput);
  myUserInterface->moveToThread(UserInterfaceThread);



  //connect user interface to CAN application



  QObject::connect(UserInterfaceThread, SIGNAL(started()), myUserInterface, SLOT(run()),Qt::DirectConnection );

  //starts the userInterface run function when can thread has started
  //connect user interface to CAN application
 // QObject::connect(myUserInterface, SIGNAL(setLoggingEnable(bool )), canInterface, SLOT(enableLogging(bool )), Qt::DirectConnection);

  //connects send frame to driver
  //QObject::connect(myUserInterface, SIGNAL(setReference(float )), flexUSB, SLOT(sendCommandFrame( comsCommandFrame  * , comsCommandFrame  * ,   control_Parameters_t * ) ), Qt::DirectConnection);

 // QObject::connect(myUserInterface, SIGNAL(setReference(float )), flexUSB, SLOT(testConnection(comsCommandFrame  * )), Qt::DirectConnection);

  // QObject::connect(myUserInterface, SIGNAL(startMotors()), canInterface, SLOT(start()), Qt::DirectConnection);
  //QObject::connect(myUserInterface, SIGNAL(stopMotors()), canInterface, SLOT(stop()), Qt::DirectConnection);
  QObject::connect(myUserInterface, SIGNAL(detachFromApp()), flexUSB, SLOT(stop()), Qt::DirectConnection);

  QObject::connect(myUserInterface, SIGNAL(setCommandAndParameterFrames(comsCommandFrame * , control_Parameters_t * )), flexUSB, SLOT(sendAllCommandFrames(comsCommandFrame * , control_Parameters_t * )), Qt::DirectConnection);


  QObject::connect(flexUSB,SIGNAL(newGanglionDataReady(ganglionData_t *)), myUserInterface, SLOT(GanglionDataDisplay(ganglionData_t *)),Qt::DirectConnection);



  UserInterfaceThread->start();


  //cin>>startMotor;
  //if (st)
  //start CAN data processing
  //canInterface->start();



  cout<<" event loop"<<endl;
  //basic event-loop
  a.exec();

  cout<<"do we return?"<<endl;


  cout<<"waiting for 0 and return!"<<endl;
  cin>>j;


  cout<<endl<<"Quitting"<<endl;

}
